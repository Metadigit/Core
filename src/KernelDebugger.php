<?php
/**
 * Metadigit Core PHP Framework
 * @link http://github.com/Metadigit/Core
 * @copyright Copyright (c) 2004-2014 Daniele Sciacchitano <dan@metadigit.it>
 * @license New BSD License
 */
namespace metadigit\core;
/**
 * Kernel extension for errors & exceptions handling
 * @author Daniele Sciacchitano <dan@metadigit.it>
 */
class KernelDebugger extends \metadigit\core\Kernel {

	const E_NOTICE = 1;
	const E_WARNING = 2;
	const E_ERROR = 3;

	/* Error level constants (@see http://www.php.net/manual/en/ref.errorfunc.php#ini.error-reporting ) */
	const LABELS = [
		E_ERROR=>'E_ERROR', /*Fatal run-time errors. These indicate errors that can not be recovered from, such as a memory allocation problem. Execution of the script is halted. */
		E_WARNING=>'E_WARNING', /* Run-time warnings (non-fatal errors). Execution of the script is not halted. */
		E_PARSE=>'E_PARSE', /* Compile-time parse errors. Parse errors should only be generated by the parser. */
		E_NOTICE=>'E_NOTICE', /* Run-time notices. Indicate that the script encountered something that could indicate an error, but could also happen in the normal course of running a script. */
		E_CORE_ERROR=>'E_CORE_ERROR',
		E_CORE_WARNING=>'E_CORE_WARNING',
		E_COMPILE_ERROR=>'E_COMPILE_ERROR',
		E_COMPILE_WARNING=>'E_COMPILE_WARNING',
		E_USER_ERROR=>'E_USER_ERROR',
		E_USER_WARNING=>'E_USER_WARNING',
		E_USER_NOTICE=>'E_USER_NOTICE',
		E_STRICT=>'E_STRICT',
		E_RECOVERABLE_ERROR=>'E_RECOVERABLE_ERROR', // since Php 5.2 !!!
	 	E_ALL=>'E_ALL'
	];

	/**
	 * Handle errors in a script.
	 * @param integer $errno      contains the level of the error raised
	 * @param string  $errstr     contains the error message
	 * @param string  $errfile    contains the filename that the error was raised in
	 * @param integer $errline    contains the file line that the error was raised in
	 * @param array   $errcontext contain an array of every variable that existed in the scope the error was triggered in
	 * @return void
	 */
	static function onError($errno, $errstr, $errfile, $errline, $errcontext) {
		if(parent::$traceError < self::E_NOTICE && in_array($errno, [E_NOTICE,E_USER_NOTICE,E_STRICT])) parent::$traceError = self::E_NOTICE;
		elseif(parent::$traceError < self::E_WARNING && in_array($errno, [E_WARNING,E_USER_WARNING])) parent::$traceError = self::E_WARNING;
		else parent::$traceError = self::E_ERROR;
		// get trace array, w/o first 3 elements (this function call)
		$trace = debug_backtrace(false);
		array_shift($trace);array_shift($trace);array_shift($trace);
		TRACE and self::traceError($errno, $errstr, $errfile, $errline, $errcontext, $trace);
		self::logError($errno, $errstr, $errfile, $errline, $errcontext, $trace);
		// @TODO call toDB() toLog() toEmail()
	}

	/**
	 * Handle uncatched exceptions.
	 * @param \Exception $Ex the Exception raised
	 */
	static function onException($Ex) {
		$level = ($Ex instanceof \metadigit\core\Exception) ? constant(get_class($Ex).'::LEVEL') : null;
		switch($level) {
			case E_USER_NOTICE: if(parent::$traceError < self::E_NOTICE) parent::$traceError = self::E_NOTICE; break;
			case E_USER_WARNING: if(parent::$traceError < self::E_WARNING) parent::$traceError = self::E_WARNING; break;
			default: parent::$traceError = self::E_ERROR;
		}
		TRACE and self::traceException($Ex);
		self::logException($Ex);
		// @TODO call toDB() toLog() toEmail()
	}

	/**
	 * Send ERROR to DebugConsole
	 * @param $errno
	 * @param $errstr
	 * @param $errfile
	 * @param $errline
	 * @param $errcontext
	 * @param $trace
	 * @return void
	 */
	static function traceError($errno, $errstr, $errfile, $errline, $errcontext, $trace) {
		$textTraceArray = self::formatTraceAsText($trace);
		$data =	'MESSAGE: '.$errstr."\n".
					'FILE: '.$errfile.':'.$errline."\n".
					'------------------------------------------------------------------------------------------------'."\n".
					implode('<br/>',$textTraceArray)."\n".
					'------------------------------------------------------------------------------------------------';
		self::trace(LOG_ERR, TRACE_ERROR, $errstr, $data, self::LABELS[$errno]);
	}

	/**
	 * Send EXCEPTION to DebugConsole
	 * @param \Exception $Ex
	 * @return void
	 */
	static function traceException($Ex) {
		$info = (is_callable([$Ex, 'getInfo'])) ? $Ex->getInfo() : null;
		$textTraceArray = self::formatTraceAsText($Ex->getTrace());
		$msg = '[CODE '.$Ex->getCode().'] '.$Ex->getMessage();
		$data =	'MESSAGE: '.$Ex->getMessage()."\n".
					'FILE: '.$Ex->getFile().':'.$Ex->getLine()."\n".
					$info."\n".
					'------------------------------------------------------------------------------------------------'."\n".
					implode("\n",$textTraceArray)."\n".
					'------------------------------------------------------------------------------------------------';
		self::trace(LOG_ERR, TRACE_ERROR, $msg, $data, get_class($Ex));
	}

	static private function logError($errno, $errstr, $errfile, $errline, $errcontext, $trace) {
		self::log(sprintf('%s - FILE: %s:%s', $errstr, $errfile, $errline), LOG_ERR, 'kernel');
	}

	static private function logException($Ex) {
		$info = (is_callable([$Ex, 'getInfo'])) ? $Ex->getInfo() : null;
		self::log(sprintf('%s[%s]: %s - %s - FILE: %s:%s', get_class($Ex), $Ex->getCode(), $Ex->getMessage(), $info, $Ex->getFile(), $Ex->getLine()), LOG_ERR, 'kernel');
	}

	static private function formatTraceAsText(array $traceArray) {
		$i = 0; $textTraceArray = [];
		foreach($traceArray as $tr) {
			if(!isset($tr['file'])) $tr['file'] = '';
			if(!isset($tr['line'])) $tr['line'] = '';
			if(!isset($tr['class'])) $tr['class'] = '';
			if(!isset($tr['type'])) $tr['type'] = '';
			$txt = '#'.$i.' '.$tr['file'].':'.$tr['line'].' -- '.$tr['class'].$tr['type'].$tr['function'].'(';
			if(!empty($tr['args'])) {
				foreach($tr['args'] as $arg) {
					switch($arg) {
						case (is_bool($arg)):
							$txt .= ($arg) ? ' true,' : ' false,';
							break;
						case (is_numeric($arg)):
							$txt .= " $arg,";
							break;
						case (is_string($arg)):
							$txt .= " '$arg',";
							break;
						case (is_array($arg)):
							$txt .= ' [Array],';
							break;
						case (is_object($arg)):
							$txt .= ' [Object],';
							break;
						default:
							$txt .= ' [mixed],';
					}
				}
				$txt = substr($txt,0,-1).' ';
			}
			$txt .= ')';
			$textTraceArray[] = $txt;
			++$i;
		}
		return $textTraceArray;
	}
}
